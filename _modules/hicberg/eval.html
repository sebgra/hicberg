

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hicberg.eval &mdash; hicberg 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            hicberg
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">hicberg</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/tutorial.html">Hicberg tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../hicberg.html">hicberg package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">hicberg</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">hicberg.eval</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for hicberg.eval</h1><div class="highlight"><pre>
<span></span><span class="c1"># import os</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">getcwd</span>
<span class="kn">import</span> <span class="nn">subprocess</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="c1"># import glob</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="c1"># import tempfile as tmpf</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">choice</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="c1"># from scipy import spatial</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">median_abs_deviation</span><span class="p">,</span> <span class="n">pearsonr</span>
<span class="kn">import</span> <span class="nn">bioframe</span> <span class="k">as</span> <span class="nn">bf</span>
<span class="kn">import</span> <span class="nn">pysam</span> <span class="k">as</span> <span class="nn">ps</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">plc</span>
<span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="k">as</span> <span class="nn">gridspec</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>

<span class="kn">import</span> <span class="nn">cooler</span>

<span class="kn">import</span> <span class="nn">hicberg.io</span> <span class="k">as</span> <span class="nn">hio</span>
<span class="kn">import</span> <span class="nn">hicberg.utils</span> <span class="k">as</span> <span class="nn">hut</span>

<div class="viewcode-block" id="get_interval_index">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_interval_index">[docs]</a>
<span class="k">def</span> <span class="nf">get_interval_index</span><span class="p">(</span><span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">value</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">intervals_dict</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">chrom_sizes_dict</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chromosome : [str]</span>
<span class="sd">        chromosome linked to value and intervals to search in.</span>
<span class="sd">    value : [int]</span>
<span class="sd">        Value to search in intervals.</span>
<span class="sd">    intervals_dict : [dict]</span>
<span class="sd">        Dictionary of intervals as key : chromosome, value : [(low_limit_0, up_limit_0), (low_limit_1, up_limit_1), ..., (low_limit_n, up_limit_n)].</span>
<span class="sd">    chrom_sizes_dict : str</span>
<span class="sd">        Path to a dictionary containing chromosome sizes as {chromosome : size} saved in .npy format. By default chromosome_sizes.npy</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    [dict]</span>
<span class="sd">        Lists of intervals (sets) where the value is not in between as element 0 and where the value is  in between as element 1.</span>
<span class="sd">        One list per chromosome in a dictionary.</span>
<span class="sd">        If the value in not in any interval, return None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># chrom_sizes_dict = hio.load_dictionary(chrom_sizes_dict)</span>

    <span class="n">out_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="p">([(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)],</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">chrom_sizes_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">intervals_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

        <span class="n">out_dict</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">intervals_dict</span><span class="p">[</span><span class="n">chrom</span><span class="p">],</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">intervals_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chrom</span><span class="p">)):</span>

            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>

                <span class="n">out_dict</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">intervals_dict</span><span class="p">[</span><span class="n">chrom</span><span class="p">][:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">intervals_dict</span><span class="p">[</span><span class="n">chrom</span><span class="p">][</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span>
                    <span class="n">intervals_dict</span><span class="p">[</span><span class="n">chrom</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_dict</span><span class="p">[</span><span class="n">chrom</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">out_dict</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="p">([(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)],</span> <span class="n">intervals_dict</span><span class="p">[</span><span class="n">chrom</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">out_dict</span></div>



<div class="viewcode-block" id="select_reads">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.select_reads">[docs]</a>
<span class="k">def</span> <span class="nf">select_reads</span><span class="p">(</span><span class="n">bam_for</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;group1.1.bam&quot;</span><span class="p">,</span> <span class="n">bam_rev</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;group1.2.bam&quot;</span><span class="p">,</span> <span class="n">matrix_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;unrescued_map.cool&quot;</span><span class="p">,</span> <span class="n">position</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">bin_size</span> <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">chrom_sizes_dict</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span>  <span class="s2">&quot;chromosome_sizes.npy&quot;</span><span class="p">,</span> <span class="n">strides</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="n">trans_chromosome</span> <span class="p">:</span>  <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">output_dir</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">trans_position</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nb_bins</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">auto</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select reads from a given matrix and alignment files. Two groups of alignment files are produced (.bam):</span>
<span class="sd">    - group1.1.in.bam and group1.2.in.bam : Forward and reverse reads from the source and target genomic interval. These reads are going to be duplicated un each intervals.</span>
<span class="sd">    - group1.1.out.bam and group1.2.out.bam : Forward and reverse reads not included the source and target genomic interval. These reads are going to be conserved and not duplicated.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bam_for : str, optional</span>
<span class="sd">        Forward alignment file to select reads from, by default &quot;group1.1.bam&quot;</span>
<span class="sd">    bam_rev : str, optional</span>
<span class="sd">        Reverse alignment file to select reads from, by default &quot;group1.2.bam&quot;</span>
<span class="sd">    matrix_file : str, optional</span>
<span class="sd">        Name of the matrix from which the selection will be based (.cool format), by default &quot;unrescued_map.cool&quot;</span>
<span class="sd">    position : int, optional</span>
<span class="sd">        Genomic coordinates (0-based) used to defined the source genomic interval, by default 0</span>
<span class="sd">    chromosome : str or list[str], optional</span>
<span class="sd">        Chromosome associated to the 0-based coordinates given by &quot;position&#39;, by default &quot;&quot;</span>
<span class="sd">    bin_size : int, optional</span>
<span class="sd">        Resolution of the given matrix, by default 2000</span>
<span class="sd">    chrom_sizes_dict : str, optional</span>
<span class="sd">        Path to a dictionary containing chromosome sizes as {chromosome : size} saved in .npy format, by default &quot;chromosome_sizes.npy&quot;</span>
<span class="sd">    strides : list[int], optional</span>
<span class="sd">        List of strides to apply from &quot;position&quot; to define target genomics intervals (in bp.), by default [0]</span>
<span class="sd">    trans_chromosome : str, optional</span>
<span class="sd">        Chromosomes to consider as trans-chromosomes to define genomic target intervals, by default None</span>
<span class="sd">    trans_position : list[int], optional</span>
<span class="sd">        Genomic coordinates (0-based) used to defined the trans-chromosomal target genomic interval, by default None</span>
<span class="sd">    nb_bins : int, optional</span>
<span class="sd">        Number of bins to consider on each side of the defined source and target intervals, by default 1</span>
<span class="sd">    random : bool, optional</span>
<span class="sd">        Set wether or not the source and target intervals are defined at random, by default False</span>
<span class="sd">    auto : int, optional</span>
<span class="sd">        Set the number of intervals to get while picking at random, by default None</span>
<span class="sd">    output_dir : str, optional</span>
<span class="sd">        Path to the folder where to save alignments, by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict[str, list[(int, int)]]</span>
<span class="sd">        Dictionary of intervals as key : chromosome, value : [(low_limit_0, up_limit_0), (low_limit_1, up_limit_1), ..., (low_limit_n, up_limit_n)].</span>

<span class="sd">    &quot;&quot;&quot;</span>   
    
    <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">output_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output path </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing output path.&quot;</span><span class="p">)</span>
    
    <span class="n">chrom_sizes_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">chrom_sizes_dict</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">chrom_sizes_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chromosome sizes file </span><span class="si">{</span><span class="n">chrom_sizes_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing chromosome sizes file.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;list&quot;</span><span class="p">:</span>

        <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">chs</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_dictionary</span><span class="p">(</span><span class="n">chrom_sizes_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">trans_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">forward_file_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">bam_for</span><span class="p">)</span>
    <span class="n">reverse_file_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">bam_rev</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">forward_file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forward bam file </span><span class="si">{</span><span class="n">forward_file_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing bam file.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse_file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reverse bam file </span><span class="si">{</span><span class="n">reverse_file_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing bam file.&quot;</span><span class="p">)</span>
    
    <span class="n">matrix_file_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">matrix_file</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix_file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matrix file </span><span class="si">{</span><span class="n">matrix_file_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing matrix file.&quot;</span><span class="p">)</span>
    
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_cooler</span><span class="p">(</span><span class="n">matrix_file_path</span><span class="p">)</span>
    
    <span class="c1"># alignment file handlers</span>
    <span class="c1"># Create handler for files to parse</span>
    <span class="n">forward_file_handler</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="n">forward_file_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
    <span class="n">reverse_file_handler</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="n">reverse_file_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>

    <span class="c1"># Create handlers for files to write</span>
    <span class="c1">## Files where selected reads and duplicates are going to be written</span>
    <span class="n">selected_reads_forward</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="s2">&quot;group1.1.in.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">forward_file_handler</span>
    <span class="p">)</span>
    <span class="n">selected_reads_reverse</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="s2">&quot;group1.2.in.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">reverse_file_handler</span>
    <span class="p">)</span>

    <span class="c1">## Files where non selected reads are going to be written</span>
    <span class="n">depleted_reads_forward</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="s2">&quot;group1.1.out.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">forward_file_handler</span>
    <span class="p">)</span>
    <span class="n">depleted_reads_reverse</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="s2">&quot;group1.2.out.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">reverse_file_handler</span>
    <span class="p">)</span>

    <span class="c1"># get acces to dictionary containing chromosomes sizes to pick random position for trans-chromosomal duplication</span>
    <span class="n">cs_disctionary</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_dictionary</span><span class="p">(</span><span class="n">chrom_sizes_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">auto</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1">## set areas and boundaries for intra-chromosomal duplications</span>
        <span class="n">forward_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">get_boundaries</span><span class="p">(</span>
                <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">stride</span><span class="p">,</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span>
                <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">stride</span> <span class="ow">in</span> <span class="n">strides</span>
        <span class="p">]</span>
        <span class="n">reverse_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">get_boundaries</span><span class="p">(</span>
                <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">stride</span><span class="p">,</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span>
                <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">stride</span> <span class="ow">in</span> <span class="n">strides</span>
        <span class="p">]</span>

        <span class="c1"># Define list of chromosome to target/duplicate read on.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">trans_chromosome</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">list_selected_chromosomes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chromosome</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">trans_chromosome</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">list_selected_chromosomes</span> <span class="o">=</span> <span class="n">chromosome</span> <span class="c1">#.split()</span>

        <span class="c1"># adjust intervals width</span>
        <span class="k">if</span> <span class="n">nb_bins</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">forward_intervals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">forward_intervals</span>
            <span class="p">]</span>
            <span class="n">reverse_intervals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">reverse_intervals</span>
            <span class="p">]</span>

        <span class="c1"># build dictionary key : chr , value : list of intervals to perform selection on</span>
        <span class="n">dictionary_of_intervals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Backup</span>
        <span class="n">dictionary_of_intervals</span><span class="p">[</span><span class="n">chromosome</span><span class="p">]</span> <span class="o">=</span> <span class="n">forward_intervals</span>

        <span class="k">if</span> <span class="n">trans_chromosome</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">trans_chromosome</span><span class="p">,</span> <span class="n">trans_position</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">random</span><span class="p">:</span>

                    <span class="n">trans_target_interval</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">get_boundaries</span><span class="p">(</span>
                            <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
                                <span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">cs_disctionary</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span>
                            <span class="p">),</span>
                            <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span>
                            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chrom</span><span class="p">,</span>
                            <span class="n">chrom_sizes_dict</span><span class="o">=</span><span class="n">chrom_sizes_path</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">]</span>

                <span class="c1"># set areas and boundaries for inter-chromosomal duplications</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="n">trans_target_interval</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">get_boundaries</span><span class="p">(</span>
                            <span class="n">position</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
                            <span class="n">bins</span><span class="o">=</span><span class="n">bin_size</span><span class="p">,</span>
                            <span class="n">chromosome</span><span class="o">=</span><span class="n">chrom</span><span class="p">,</span>
                            <span class="n">chrom_sizes_dict</span><span class="o">=</span><span class="n">chrom_sizes_path</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">]</span>

                <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictionary_of_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                    <span class="n">dictionary_of_intervals</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_target_interval</span>

    <span class="k">if</span> <span class="n">auto</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">dictionary_of_intervals</span> <span class="o">=</span> <span class="n">draw_intervals</span><span class="p">(</span><span class="n">chrom_sizes_dict</span>  <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span> <span class="n">nb_intervals</span> <span class="o">=</span> <span class="n">auto</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">)</span>

        <span class="c1"># If a randomly selected interval is empty, draw another set of intervals</span>
        <span class="k">while</span> <span class="n">check_emptiness</span><span class="p">(</span><span class="n">intervals</span> <span class="o">=</span> <span class="n">dictionary_of_intervals</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">):</span>
                
            <span class="n">dictionary_of_intervals</span> <span class="o">=</span> <span class="n">draw_intervals</span><span class="p">(</span><span class="n">chrom_sizes_dict</span>  <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span> <span class="n">nb_intervals</span> <span class="o">=</span> <span class="n">auto</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">)</span>

        <span class="n">list_selected_chromosomes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dictionary_of_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># parse both alignment files to eventually duplicate reads</span>
    <span class="k">for</span> <span class="n">forward_read</span><span class="p">,</span> <span class="n">reverse_read</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">forward_file_handler</span><span class="p">,</span> <span class="n">reverse_file_handler</span><span class="p">):</span>

        <span class="c1"># Default save status</span>
        <span class="n">save</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">## Order reads by coordinates</span>
        <span class="n">ordered_forward_read</span><span class="p">,</span> <span class="n">ordered_reverse_read</span> <span class="o">=</span> <span class="n">hut</span><span class="o">.</span><span class="n">get_ordered_reads</span><span class="p">(</span>
            <span class="n">forward_read</span><span class="p">,</span> <span class="n">reverse_read</span>
        <span class="p">)</span>

        <span class="c1"># Avoid cases where chromosomes are not concerned for duplication</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">forward_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_selected_chromosomes</span>
            <span class="ow">and</span> <span class="n">reverse_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_selected_chromosomes</span>
        <span class="p">):</span>  <span class="c1"># or backp</span>
            <span class="n">depleted_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">forward_read</span><span class="p">)</span>
            <span class="n">depleted_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">reverse_read</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Search for intervals where reads potentially belong</span>
        <span class="n">forward_interval_search</span> <span class="o">=</span> <span class="n">get_interval_index</span><span class="p">(</span>
            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">,</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">intervals_dict</span> <span class="o">=</span> <span class="n">dictionary_of_intervals</span><span class="p">,</span>
            <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">reverse_interval_search</span> <span class="o">=</span> <span class="n">get_interval_index</span><span class="p">(</span>
            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">,</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">intervals_dict</span> <span class="o">=</span> <span class="n">dictionary_of_intervals</span><span class="p">,</span>
            <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Case where both forward and reverse reads belong to any of the selected of target interval</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1"># Do duplication and write + set save to false</span>
            <span class="c1">## original forward and reverse reads save</span>
            <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># Compute forward and reverse shifts</span>
            <span class="n">forward_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span>
                <span class="o">-</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [0] : select lower bound of this interval</span>
            <span class="n">reverse_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [1] : select upper bound of this interval</span>

            <span class="c1"># Duplicate and save both reads to corresponding files</span>
            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">forward_interval</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">forward_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">forward_shift</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XC&quot;</span><span class="p">,</span> <span class="s2">&quot;Case_0&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">reverse_interval</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">reverse_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">reverse_shift</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XC&quot;</span><span class="p">,</span> <span class="s2">&quot;Case_0&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># set save at false</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Case where only forward read belong to any of selected or target interval</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1">## original forward and reverse reads save</span>
            <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># Compute forward  shifts</span>
            <span class="n">forward_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span>
                <span class="o">-</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [0] : select lower bound of this interval</span>

            <span class="c1"># Do duplication of forward read on all potential interval and save all duplicates</span>
            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">forward_interval</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">forward_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">forward_shift</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>

            <span class="c1"># set save to false</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Case where only reverse belong to selected or target intervals</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1">## original forward and reverse reads save</span>
            <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># Compute reverse  shifts</span>
            <span class="n">reverse_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [1] : select upper bound of this interval</span>

            <span class="c1"># Do duplication of reverse read on all potential interval and save all duplicates</span>
            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">reverse_interval</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">reverse_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">reverse_shift</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># set save at false</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Write unselected reads to their corresponding files</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>

            <span class="n">depleted_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">depleted_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

    <span class="c1"># close all files</span>
    <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">depleted_reads_forward</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">depleted_reads_reverse</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">forward_file_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">reverse_file_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">dictionary_of_intervals</span></div>



<div class="viewcode-block" id="select_reads_multithreads_bckp">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.select_reads_multithreads_bckp">[docs]</a>
<span class="k">def</span> <span class="nf">select_reads_multithreads_bckp</span><span class="p">(</span><span class="n">bam_couple</span> <span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">matrix_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;unrescued_map.cool&quot;</span><span class="p">,</span> <span class="n">position</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">bin_size</span> <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">chrom_sizes_dict</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span>  <span class="s2">&quot;chromosome_sizes.npy&quot;</span><span class="p">,</span> <span class="n">strides</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="n">trans_chromosome</span> <span class="p">:</span>  <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">output_dir</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">trans_position</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nb_bins</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">auto</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select reads from a given matrix and alignment files. Two groups of alignment files are produced (.bam):</span>
<span class="sd">    - group1.1.in.bam and group1.2.in.bam : Forward and reverse reads from the source and target genomic interval. These reads are going to be duplicated un each intervals.</span>
<span class="sd">    - group1.1.out.bam and group1.2.out.bam : Forward and reverse reads not included the source and target genomic interval. These reads are going to be conserved and not duplicated.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bam_for : str, optional</span>
<span class="sd">        Forward alignment file to select reads from, by default &quot;group1.1.bam&quot;</span>
<span class="sd">    bam_rev : str, optional</span>
<span class="sd">        Reverse alignment file to select reads from, by default &quot;group1.2.bam&quot;</span>
<span class="sd">    matrix_file : str, optional</span>
<span class="sd">        Name of the matrix from which the selection will be based (.cool format), by default &quot;unrescued_map.cool&quot;</span>
<span class="sd">    position : int, optional</span>
<span class="sd">        Genomic coordinates (0-based) used to defined the source genomic interval, by default 0</span>
<span class="sd">    chromosome : str or list[str], optional</span>
<span class="sd">        Chromosome associated to the 0-based coordinates given by &quot;position&#39;, by default &quot;&quot;</span>
<span class="sd">    bin_size : int, optional</span>
<span class="sd">        Resolution of the given matrix, by default 2000</span>
<span class="sd">    chrom_sizes_dict : str, optional</span>
<span class="sd">        Path to a dictionary containing chromosome sizes as {chromosome : size} saved in .npy format, by default &quot;chromosome_sizes.npy&quot;</span>
<span class="sd">    strides : list[int], optional</span>
<span class="sd">        List of strides to apply from &quot;position&quot; to define target genomics intervals (in bp.), by default [0]</span>
<span class="sd">    trans_chromosome : str, optional</span>
<span class="sd">        Chromosomes to consider as trans-chromosomes to define genomic target intervals, by default None</span>
<span class="sd">    trans_position : list[int], optional</span>
<span class="sd">        Genomic coordinates (0-based) used to defined the trans-chromosomal target genomic interval, by default None</span>
<span class="sd">    nb_bins : int, optional</span>
<span class="sd">        Number of bins to consider on each side of the defined source and target intervals, by default 1</span>
<span class="sd">    random : bool, optional</span>
<span class="sd">        Set wether or not the source and target intervals are defined at random, by default False</span>
<span class="sd">    auto : int, optional</span>
<span class="sd">        Set the number of intervals to get while picking at random, by default None</span>
<span class="sd">    output_dir : str, optional</span>
<span class="sd">        Path to the folder where to save alignments, by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict[str, list[(int, int)]]</span>
<span class="sd">        Dictionary of intervals as key : chromosome, value : [(low_limit_0, up_limit_0), (low_limit_1, up_limit_1), ..., (low_limit_n, up_limit_n)].</span>

<span class="sd">    &quot;&quot;&quot;</span>   
    
    <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">output_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output path </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing output path.&quot;</span><span class="p">)</span>
    
    <span class="n">chrom_sizes_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">chrom_sizes_dict</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">chrom_sizes_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chromosome sizes file </span><span class="si">{</span><span class="n">chrom_sizes_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing chromosome sizes file.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;list&quot;</span><span class="p">:</span>

        <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">chs</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_dictionary</span><span class="p">(</span><span class="n">chrom_sizes_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">trans_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># print(f&quot;bam for : {bam_for}&quot;)</span>
    <span class="c1"># print(f&quot;bam rev : {bam_rev}&quot;)</span>
    <span class="n">forward_file_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">bam_couple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">reverse_file_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">bam_couple</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">forward_file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forward bam file </span><span class="si">{</span><span class="n">forward_file_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing bam file.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse_file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reverse bam file </span><span class="si">{</span><span class="n">reverse_file_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing bam file.&quot;</span><span class="p">)</span>
    
    <span class="n">matrix_file_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">matrix_file</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix_file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matrix file </span><span class="si">{</span><span class="n">matrix_file_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing matrix file.&quot;</span><span class="p">)</span>
    
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_cooler</span><span class="p">(</span><span class="n">matrix_file_path</span><span class="p">)</span>
    
    <span class="c1"># alignment file handlers</span>
    <span class="c1"># Create handler for files to parse</span>
    <span class="n">forward_file_handler</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="n">forward_file_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
    <span class="n">reverse_file_handler</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="n">reverse_file_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>

    <span class="c1"># Create handlers for files to write</span>
    <span class="c1">## Files where selected reads and duplicates are going to be written</span>
    <span class="n">selected_reads_forward</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">forward_file_path</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s2">.in.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">forward_file_handler</span>
    <span class="p">)</span>
    <span class="n">selected_reads_reverse</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">reverse_file_path</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s2">.in.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">reverse_file_handler</span>
    <span class="p">)</span>

    <span class="c1">## Files where non selected reads are going to be written</span>
    <span class="n">depleted_reads_forward</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">forward_file_path</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s2">.out.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">forward_file_handler</span>
    <span class="p">)</span>
    <span class="n">depleted_reads_reverse</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">reverse_file_path</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s2">.out.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">reverse_file_handler</span>
    <span class="p">)</span>

    <span class="c1"># get acces to dictionary containing chromosomes sizes to pick random position for trans-chromosomal duplication</span>
    <span class="n">cs_disctionary</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_dictionary</span><span class="p">(</span><span class="n">chrom_sizes_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">auto</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1">## set areas and boundaries for intra-chromosomal duplications</span>
        <span class="n">forward_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">get_boundaries</span><span class="p">(</span>
                <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">stride</span><span class="p">,</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span>
                <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">stride</span> <span class="ow">in</span> <span class="n">strides</span>
        <span class="p">]</span>
        <span class="n">reverse_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">get_boundaries</span><span class="p">(</span>
                <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">stride</span><span class="p">,</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span>
                <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">stride</span> <span class="ow">in</span> <span class="n">strides</span>
        <span class="p">]</span>

        <span class="c1"># Define list of chromosome to target/duplicate read on.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">trans_chromosome</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">list_selected_chromosomes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chromosome</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">trans_chromosome</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">list_selected_chromosomes</span> <span class="o">=</span> <span class="n">chromosome</span> <span class="c1">#.split()</span>

        <span class="c1"># adjust intervals width</span>
        <span class="k">if</span> <span class="n">nb_bins</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">forward_intervals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">forward_intervals</span>
            <span class="p">]</span>
            <span class="n">reverse_intervals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">reverse_intervals</span>
            <span class="p">]</span>

        <span class="c1"># build dictionary key : chr , value : list of intervals to perform selection on</span>
        <span class="n">dictionary_of_intervals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Backup</span>
        <span class="n">dictionary_of_intervals</span><span class="p">[</span><span class="n">chromosome</span><span class="p">]</span> <span class="o">=</span> <span class="n">forward_intervals</span>

        <span class="k">if</span> <span class="n">trans_chromosome</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">trans_chromosome</span><span class="p">,</span> <span class="n">trans_position</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">random</span><span class="p">:</span>

                    <span class="n">trans_target_interval</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">get_boundaries</span><span class="p">(</span>
                            <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
                                <span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">cs_disctionary</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span>
                            <span class="p">),</span>
                            <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span>
                            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chrom</span><span class="p">,</span>
                            <span class="n">chrom_sizes_dict</span><span class="o">=</span><span class="n">chrom_sizes_path</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">]</span>

                <span class="c1"># set areas and boundaries for inter-chromosomal duplications</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="n">trans_target_interval</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">get_boundaries</span><span class="p">(</span>
                            <span class="n">position</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
                            <span class="n">bins</span><span class="o">=</span><span class="n">bin_size</span><span class="p">,</span>
                            <span class="n">chromosome</span><span class="o">=</span><span class="n">chrom</span><span class="p">,</span>
                            <span class="n">chrom_sizes_dict</span><span class="o">=</span><span class="n">chrom_sizes_path</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">]</span>

                <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictionary_of_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                    <span class="n">dictionary_of_intervals</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_target_interval</span>

    <span class="k">if</span> <span class="n">auto</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">dictionary_of_intervals</span> <span class="o">=</span> <span class="n">draw_intervals</span><span class="p">(</span><span class="n">chrom_sizes_dict</span>  <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span> <span class="n">nb_intervals</span> <span class="o">=</span> <span class="n">auto</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">)</span>

        <span class="c1"># If a randomly selected interval is empty, draw another set of intervals</span>
        <span class="k">while</span> <span class="n">check_emptiness</span><span class="p">(</span><span class="n">intervals</span> <span class="o">=</span> <span class="n">dictionary_of_intervals</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">):</span>
                
            <span class="n">dictionary_of_intervals</span> <span class="o">=</span> <span class="n">draw_intervals</span><span class="p">(</span><span class="n">chrom_sizes_dict</span>  <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span> <span class="n">nb_intervals</span> <span class="o">=</span> <span class="n">auto</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">)</span>

        <span class="n">list_selected_chromosomes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dictionary_of_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># parse both alignment files to eventually duplicate reads</span>
    <span class="k">for</span> <span class="n">forward_read</span><span class="p">,</span> <span class="n">reverse_read</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">forward_file_handler</span><span class="p">,</span> <span class="n">reverse_file_handler</span><span class="p">):</span>

        <span class="c1"># Default save status</span>
        <span class="n">save</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">## Order reads by coordinates</span>
        <span class="n">ordered_forward_read</span><span class="p">,</span> <span class="n">ordered_reverse_read</span> <span class="o">=</span> <span class="n">hut</span><span class="o">.</span><span class="n">get_ordered_reads</span><span class="p">(</span>
            <span class="n">forward_read</span><span class="p">,</span> <span class="n">reverse_read</span>
        <span class="p">)</span>

        <span class="c1"># Avoid cases where chromosomes are not concerned for duplication</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">forward_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_selected_chromosomes</span>
            <span class="ow">and</span> <span class="n">reverse_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_selected_chromosomes</span>
        <span class="p">):</span>  <span class="c1"># or backp</span>
            <span class="n">depleted_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">forward_read</span><span class="p">)</span>
            <span class="n">depleted_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">reverse_read</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Search for intervals where reads potentially belong</span>
        <span class="n">forward_interval_search</span> <span class="o">=</span> <span class="n">get_interval_index</span><span class="p">(</span>
            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">,</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">intervals_dict</span> <span class="o">=</span> <span class="n">dictionary_of_intervals</span><span class="p">,</span>
            <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">reverse_interval_search</span> <span class="o">=</span> <span class="n">get_interval_index</span><span class="p">(</span>
            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">,</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">intervals_dict</span> <span class="o">=</span> <span class="n">dictionary_of_intervals</span><span class="p">,</span>
            <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Case where both forward and reverse reads belong to any of the selected of target interval</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1"># Do duplication and write + set save to false</span>
            <span class="c1">## original forward and reverse reads save</span>
            <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># Compute forward and reverse shifts</span>
            <span class="n">forward_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span>
                <span class="o">-</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [0] : select lower bound of this interval</span>
            <span class="n">reverse_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [1] : select upper bound of this interval</span>

            <span class="c1"># Duplicate and save both reads to corresponding files</span>
            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">forward_interval</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">forward_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">forward_shift</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XC&quot;</span><span class="p">,</span> <span class="s2">&quot;Case_0&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">reverse_interval</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">reverse_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">reverse_shift</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XC&quot;</span><span class="p">,</span> <span class="s2">&quot;Case_0&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># set save at false</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Case where only forward read belong to any of selected or target interval</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1">## original forward and reverse reads save</span>
            <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># Compute forward  shifts</span>
            <span class="n">forward_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span>
                <span class="o">-</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [0] : select lower bound of this interval</span>

            <span class="c1"># Do duplication of forward read on all potential interval and save all duplicates</span>
            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">forward_interval</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">forward_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">forward_shift</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>

            <span class="c1"># set save to false</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Case where only reverse belong to selected or target intervals</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1">## original forward and reverse reads save</span>
            <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># Compute reverse  shifts</span>
            <span class="n">reverse_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [1] : select upper bound of this interval</span>

            <span class="c1"># Do duplication of reverse read on all potential interval and save all duplicates</span>
            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">reverse_interval</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">reverse_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">reverse_shift</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># set save at false</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Write unselected reads to their corresponding files</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>

            <span class="n">depleted_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">depleted_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

    <span class="c1"># close all files</span>
    <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">depleted_reads_forward</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">depleted_reads_reverse</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">forward_file_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">reverse_file_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">dictionary_of_intervals</span></div>



<div class="viewcode-block" id="select_reads_multithreads">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.select_reads_multithreads">[docs]</a>
<span class="k">def</span> <span class="nf">select_reads_multithreads</span><span class="p">(</span><span class="n">bam_couple</span> <span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">interval_dictionary</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)],</span>  <span class="n">chrom_sizes_dict</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span>  <span class="s2">&quot;chromosome_sizes.npy&quot;</span><span class="p">,</span> <span class="n">output_dir</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select reads from a given matrix and alignment files. Two groups of alignment files are produced (.bam):</span>
<span class="sd">    - group1.1.in.bam and group1.2.in.bam : Forward and reverse reads from the source and target genomic interval. These reads are going to be duplicated un each intervals.</span>
<span class="sd">    - group1.1.out.bam and group1.2.out.bam : Forward and reverse reads not included the source and target genomic interval. These reads are going to be conserved and not duplicated.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bam_for : str, optional</span>
<span class="sd">        Forward alignment file to select reads from, by default &quot;group1.1.bam&quot;</span>
<span class="sd">    bam_rev : str, optional</span>
<span class="sd">        Reverse alignment file to select reads from, by default &quot;group1.2.bam&quot;</span>
<span class="sd">    matrix_file : str, optional</span>
<span class="sd">        Name of the matrix from which the selection will be based (.cool format), by default &quot;unrescued_map.cool&quot;</span>
<span class="sd">    position : int, optional</span>
<span class="sd">        Genomic coordinates (0-based) used to defined the source genomic interval, by default 0</span>
<span class="sd">    chromosome : str or list[str], optional</span>
<span class="sd">        Chromosome associated to the 0-based coordinates given by &quot;position&#39;, by default &quot;&quot;</span>
<span class="sd">    bin_size : int, optional</span>
<span class="sd">        Resolution of the given matrix, by default 2000</span>
<span class="sd">    chrom_sizes_dict : str, optional</span>
<span class="sd">        Path to a dictionary containing chromosome sizes as {chromosome : size} saved in .npy format, by default &quot;chromosome_sizes.npy&quot;</span>
<span class="sd">    strides : list[int], optional</span>
<span class="sd">        List of strides to apply from &quot;position&quot; to define target genomics intervals (in bp.), by default [0]</span>
<span class="sd">    trans_chromosome : str, optional</span>
<span class="sd">        Chromosomes to consider as trans-chromosomes to define genomic target intervals, by default None</span>
<span class="sd">    trans_position : list[int], optional</span>
<span class="sd">        Genomic coordinates (0-based) used to defined the trans-chromosomal target genomic interval, by default None</span>
<span class="sd">    nb_bins : int, optional</span>
<span class="sd">        Number of bins to consider on each side of the defined source and target intervals, by default 1</span>
<span class="sd">    random : bool, optional</span>
<span class="sd">        Set wether or not the source and target intervals are defined at random, by default False</span>
<span class="sd">    auto : int, optional</span>
<span class="sd">        Set the number of intervals to get while picking at random, by default None</span>
<span class="sd">    output_dir : str, optional</span>
<span class="sd">        Path to the folder where to save alignments, by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict[str, list[(int, int)]]</span>
<span class="sd">        Dictionary of intervals as key : chromosome, value : [(low_limit_0, up_limit_0), (low_limit_1, up_limit_1), ..., (low_limit_n, up_limit_n)].</span>

<span class="sd">    &quot;&quot;&quot;</span>   
    
    <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">output_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output path </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing output path.&quot;</span><span class="p">)</span>
    
    <span class="n">chrom_sizes_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">chrom_sizes_dict</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">chrom_sizes_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chromosome sizes file </span><span class="si">{</span><span class="n">chrom_sizes_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing chromosome sizes file.&quot;</span><span class="p">)</span>
    
    <span class="n">forward_file_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">bam_couple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">reverse_file_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">bam_couple</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">forward_file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forward bam file </span><span class="si">{</span><span class="n">forward_file_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing bam file.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse_file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reverse bam file </span><span class="si">{</span><span class="n">reverse_file_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing bam file.&quot;</span><span class="p">)</span>

    
    <span class="c1"># alignment file handlers</span>
    <span class="c1"># Create handler for files to parse</span>
    <span class="n">forward_file_handler</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="n">forward_file_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
    <span class="n">reverse_file_handler</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="n">reverse_file_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>

    <span class="c1"># Create handlers for files to write</span>
    <span class="c1">## Files where selected reads and duplicates are going to be written</span>
    <span class="n">selected_reads_forward</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">forward_file_path</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s2">.in.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">forward_file_handler</span>
    <span class="p">)</span>
    <span class="n">selected_reads_reverse</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">reverse_file_path</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s2">.in.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">reverse_file_handler</span>
    <span class="p">)</span>

    <span class="c1">## Files where non selected reads are going to be written</span>
    <span class="n">depleted_reads_forward</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">forward_file_path</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s2">.out.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">forward_file_handler</span>
    <span class="p">)</span>
    <span class="n">depleted_reads_reverse</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span>
        <span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">reverse_file_path</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s2">.out.bam&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">reverse_file_handler</span>
    <span class="p">)</span>

    <span class="c1"># get acces to dictionary containing chromosomes sizes to pick random position for trans-chromosomal duplication</span>
    <span class="n">chs</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_dictionary</span><span class="p">(</span><span class="n">chrom_sizes_path</span><span class="p">)</span>

    <span class="n">list_selected_chromosomes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">interval_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="c1"># parse both alignment files to eventually duplicate reads</span>
    <span class="k">for</span> <span class="n">forward_read</span><span class="p">,</span> <span class="n">reverse_read</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">forward_file_handler</span><span class="p">,</span> <span class="n">reverse_file_handler</span><span class="p">):</span>

        <span class="c1"># Default save status</span>
        <span class="n">save</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">## Order reads by coordinates</span>
        <span class="n">ordered_forward_read</span><span class="p">,</span> <span class="n">ordered_reverse_read</span> <span class="o">=</span> <span class="n">hut</span><span class="o">.</span><span class="n">get_ordered_reads</span><span class="p">(</span>
            <span class="n">forward_read</span><span class="p">,</span> <span class="n">reverse_read</span>
        <span class="p">)</span>

        <span class="c1"># Avoid cases where chromosomes are not concerned for duplication</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">forward_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_selected_chromosomes</span>
            <span class="ow">and</span> <span class="n">reverse_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_selected_chromosomes</span>
        <span class="p">):</span>  <span class="c1"># or backp</span>
            <span class="n">depleted_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">forward_read</span><span class="p">)</span>
            <span class="n">depleted_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">reverse_read</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Search for intervals where reads potentially belong</span>
        <span class="n">forward_interval_search</span> <span class="o">=</span> <span class="n">get_interval_index</span><span class="p">(</span>
            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">,</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">intervals_dict</span> <span class="o">=</span> <span class="n">interval_dictionary</span><span class="p">,</span>
            <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">reverse_interval_search</span> <span class="o">=</span> <span class="n">get_interval_index</span><span class="p">(</span>
            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">,</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">intervals_dict</span> <span class="o">=</span> <span class="n">interval_dictionary</span><span class="p">,</span>
            <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Case where both forward and reverse reads belong to any of the selected of target interval</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1"># Do duplication and write + set save to false</span>
            <span class="c1">## original forward and reverse reads save</span>
            <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># Compute forward and reverse shifts</span>
            <span class="n">forward_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span>
                <span class="o">-</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [0] : select lower bound of this interval</span>
            <span class="n">reverse_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [1] : select upper bound of this interval</span>

            <span class="c1"># Duplicate and save both reads to corresponding files</span>
            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">forward_interval</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">forward_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">forward_shift</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XC&quot;</span><span class="p">,</span> <span class="s2">&quot;Case_0&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">reverse_interval</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">reverse_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">reverse_shift</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XC&quot;</span><span class="p">,</span> <span class="s2">&quot;Case_0&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># set save at false</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Case where only forward read belong to any of selected or target interval</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1">## original forward and reverse reads save</span>
            <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># Compute forward  shifts</span>
            <span class="n">forward_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span>
                <span class="o">-</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [0] : select lower bound of this interval</span>

            <span class="c1"># Do duplication of forward read on all potential interval and save all duplicates</span>
            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">forward_interval</span> <span class="ow">in</span> <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">forward_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">forward_shift</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>

            <span class="c1"># set save to false</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Case where only reverse belong to selected or target intervals</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">forward_interval_search</span><span class="p">[</span><span class="n">ordered_forward_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>

            <span class="c1">## original forward and reverse reads save</span>
            <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># Compute reverse  shifts</span>
            <span class="n">reverse_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span>
            <span class="p">)</span>  <span class="c1"># [1] : interval where the read is initially - [1] : select upper bound of this interval</span>

            <span class="c1"># Do duplication of reverse read on all potential interval and save all duplicates</span>
            <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># Check if forward read reference has valid intervals</span>
                <span class="k">if</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">reverse_interval</span> <span class="ow">in</span> <span class="n">reverse_interval_search</span><span class="p">[</span><span class="n">chromosome</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]:</span>  <span class="c1"># parse all intervals where the read is not initially</span>

                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">reverse_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">reverse_shift</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">=</span> <span class="n">chromosome</span>
                        <span class="n">ordered_reverse_read</span><span class="o">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s2">&quot;XF&quot;</span><span class="p">,</span> <span class="s2">&quot;Fake&quot;</span><span class="p">)</span>
                        <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

            <span class="c1"># set save at false</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Write unselected reads to their corresponding files</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>

            <span class="n">depleted_reads_forward</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_forward_read</span><span class="p">)</span>
            <span class="n">depleted_reads_reverse</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ordered_reverse_read</span><span class="p">)</span>

    <span class="c1"># close all files</span>
    <span class="n">selected_reads_forward</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">selected_reads_reverse</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">depleted_reads_forward</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">depleted_reads_reverse</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">forward_file_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">reverse_file_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="generate_dict_coordinates">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.generate_dict_coordinates">[docs]</a>
<span class="k">def</span> <span class="nf">generate_dict_coordinates</span><span class="p">(</span><span class="n">matrix_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;unrescued_map.cool&quot;</span><span class="p">,</span> <span class="n">position</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">bin_size</span> <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">chrom_sizes_dict</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span>  <span class="s2">&quot;chromosome_sizes.npy&quot;</span><span class="p">,</span> <span class="n">strides</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="n">trans_chromosome</span> <span class="p">:</span>  <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">output_dir</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">trans_position</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nb_bins</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">auto</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a dictionary of genomic coordinates for selecting regions in a Hi-C contact map.</span>

<span class="sd">    This function defines genomic intervals based on provided parameters such as chromosome, position, strides, and bin size. </span>
<span class="sd">    It can generate intervals for both intra-chromosomal and inter-chromosomal interactions. The intervals can be used to </span>
<span class="sd">    select specific regions in a Hi-C contact map for further analysis, such as simulating deletions or duplications.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    matrix_file : str, optional</span>
<span class="sd">        Path to the cooler file containing the Hi-C contact map, by default &quot;unrescued_map.cool&quot;</span>
<span class="sd">    position : int, optional</span>
<span class="sd">        Genomic position on the chromosome, by default 0</span>
<span class="sd">    chromosome : str | list[str], optional</span>
<span class="sd">        Chromosome or list of chromosomes, by default &quot;&quot;</span>
<span class="sd">    bin_size : int, optional</span>
<span class="sd">        Size of the bins in the Hi-C contact map, by default 2000</span>
<span class="sd">    chrom_sizes_dict : str, optional</span>
<span class="sd">        Path to the chromosome sizes dictionary, by default &quot;chromosome_sizes.npy&quot;</span>
<span class="sd">    strides : list[int], optional</span>
<span class="sd">        List of strides to use for generating intervals, by default [0]</span>
<span class="sd">    trans_chromosome : str, optional</span>
<span class="sd">        Chromosome for trans-interactions, by default None</span>
<span class="sd">    output_dir : str, optional</span>
<span class="sd">        Path to the output directory, by default None</span>
<span class="sd">    trans_position : list[int], optional</span>
<span class="sd">        List of positions on the trans-chromosome, by default None</span>
<span class="sd">    nb_bins : int, optional</span>
<span class="sd">        Number of bins to include in each interval, by default 1</span>
<span class="sd">    random : bool, optional</span>
<span class="sd">        Whether to generate random intervals, by default False</span>
<span class="sd">    auto : int, optional</span>
<span class="sd">        Number of random intervals to generate, by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict[str, list[(int, int)]]</span>
<span class="sd">        A dictionary where keys are chromosomes and values are lists of (start, end) genomic intervals.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the output path, chromosome sizes file, or matrix file does not exist.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">output_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output path </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing output path.&quot;</span><span class="p">)</span>

    <span class="n">chrom_sizes_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">chrom_sizes_dict</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">chrom_sizes_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chromosome sizes file </span><span class="si">{</span><span class="n">chrom_sizes_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing chromosome sizes file.&quot;</span><span class="p">)</span>

    <span class="n">matrix_file_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">matrix_file</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix_file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matrix file </span><span class="si">{</span><span class="n">matrix_file_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing matrix file.&quot;</span><span class="p">)</span>
    
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_cooler</span><span class="p">(</span><span class="n">matrix_file_path</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;list&quot;</span><span class="p">:</span>

        <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">chs</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_dictionary</span><span class="p">(</span><span class="n">chrom_sizes_path</span><span class="p">)</span>

        <span class="c1"># get acces to dictionary containing chromosomes sizes to pick random position for trans-chromosomal duplication</span>
    <span class="n">cs_disctionary</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_dictionary</span><span class="p">(</span><span class="n">chrom_sizes_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">auto</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1">## set areas and boundaries for intra-chromosomal duplications</span>
        <span class="n">forward_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">get_boundaries</span><span class="p">(</span>
                <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">stride</span><span class="p">,</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span>
                <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">stride</span> <span class="ow">in</span> <span class="n">strides</span>
        <span class="p">]</span>
        <span class="n">reverse_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">get_boundaries</span><span class="p">(</span>
                <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">stride</span><span class="p">,</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span>
                <span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">stride</span> <span class="ow">in</span> <span class="n">strides</span>
        <span class="p">]</span>

        <span class="c1"># Define list of chromosome to target/duplicate read on.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">trans_chromosome</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">list_selected_chromosomes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chromosome</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">trans_chromosome</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">list_selected_chromosomes</span> <span class="o">=</span> <span class="n">chromosome</span> <span class="c1">#.split()</span>

        <span class="c1"># adjust intervals width</span>
        <span class="k">if</span> <span class="n">nb_bins</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">forward_intervals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">forward_intervals</span>
            <span class="p">]</span>
            <span class="n">reverse_intervals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                    <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">reverse_intervals</span>
            <span class="p">]</span>

        <span class="c1"># build dictionary key : chr , value : list of intervals to perform selection on</span>
        <span class="n">dictionary_of_intervals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Backup</span>
        <span class="n">dictionary_of_intervals</span><span class="p">[</span><span class="n">chromosome</span><span class="p">]</span> <span class="o">=</span> <span class="n">forward_intervals</span>

        <span class="k">if</span> <span class="n">trans_chromosome</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">trans_chromosome</span><span class="p">,</span> <span class="n">trans_position</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">random</span><span class="p">:</span>

                    <span class="n">trans_target_interval</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">get_boundaries</span><span class="p">(</span>
                            <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
                                <span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">cs_disctionary</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span>
                            <span class="p">),</span>
                            <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span>
                            <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chrom</span><span class="p">,</span>
                            <span class="n">chrom_sizes_dict</span><span class="o">=</span><span class="n">chrom_sizes_path</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">]</span>

                <span class="c1"># set areas and boundaries for inter-chromosomal duplications</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="n">trans_target_interval</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">get_boundaries</span><span class="p">(</span>
                            <span class="n">position</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
                            <span class="n">bins</span><span class="o">=</span><span class="n">bin_size</span><span class="p">,</span>
                            <span class="n">chromosome</span><span class="o">=</span><span class="n">chrom</span><span class="p">,</span>
                            <span class="n">chrom_sizes_dict</span><span class="o">=</span><span class="n">chrom_sizes_path</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">]</span>

                <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictionary_of_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                    <span class="n">dictionary_of_intervals</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_target_interval</span>

    <span class="k">if</span> <span class="n">auto</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">dictionary_of_intervals</span> <span class="o">=</span> <span class="n">draw_intervals</span><span class="p">(</span><span class="n">chrom_sizes_dict</span>  <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span> <span class="n">nb_intervals</span> <span class="o">=</span> <span class="n">auto</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">)</span>

        <span class="c1"># If a randomly selected interval is empty, draw another set of intervals</span>
        <span class="k">while</span> <span class="n">check_emptiness</span><span class="p">(</span><span class="n">intervals</span> <span class="o">=</span> <span class="n">dictionary_of_intervals</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">):</span>
                
            <span class="n">dictionary_of_intervals</span> <span class="o">=</span> <span class="n">draw_intervals</span><span class="p">(</span><span class="n">chrom_sizes_dict</span>  <span class="o">=</span> <span class="n">chrom_sizes_path</span><span class="p">,</span> <span class="n">nb_intervals</span> <span class="o">=</span> <span class="n">auto</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">)</span>

        <span class="n">list_selected_chromosomes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dictionary_of_intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">dictionary_of_intervals</span></div>


<div class="viewcode-block" id="get_intervals_proportions">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_intervals_proportions">[docs]</a>
<span class="k">def</span> <span class="nf">get_intervals_proportions</span><span class="p">(</span><span class="n">chrom_sizes_dict</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;chromosome_sizes.npy&quot;</span><span class="p">,</span> <span class="n">nb_intervals</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a dictionary containing the number of intervals to draw considering the size of each chromosome.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chrom_sizes_dict : str</span>
<span class="sd">        Path to a dictionary containing chromosome sizes as {chromosome : size} saved in .npy format. By default chromosome_sizes.npy</span>
<span class="sd">    nb_intervals : int, optional</span>
<span class="sd">        Number of intervals to draw, by default 1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict[str, int]</span>
<span class="sd">        Dictionary containing proportion by intervals as {chromosome : proportion}.</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="n">chrom_sizes_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">chrom_sizes_dict</span><span class="p">)</span>
    <span class="n">chrom_sizes</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_dictionary</span><span class="p">(</span><span class="n">chrom_sizes_path</span><span class="p">)</span>

    <span class="c1"># Get genome global length</span>
    <span class="n">tot_genome_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chrom_sizes</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="c1"># Compute relative proportion of each chromosome through genome</span>
    <span class="n">chr_proportions</span>  <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="p">:</span> <span class="p">(</span><span class="n">v</span> <span class="o">/</span> <span class="n">tot_genome_length</span><span class="p">)</span>  <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">chrom_sizes</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">chrom_sizes</span><span class="o">.</span><span class="n">values</span><span class="p">())}</span>

    <span class="c1"># Draw chromosomes considering their relative proportion in genome</span>
    <span class="n">proportions_choice</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chr_proportions</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nb_intervals</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chr_proportions</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="c1"># Get and return chromosomes picked and counts</span>
    <span class="n">unique</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">proportions_choice</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span> <span class="n">counts</span><span class="p">))</span></div>



<div class="viewcode-block" id="get_chromosomes_intervals">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_chromosomes_intervals">[docs]</a>
<span class="k">def</span> <span class="nf">get_chromosomes_intervals</span><span class="p">(</span><span class="n">bins</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">chrom_sizes_dict</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;chromosome_sizes.npy&quot;</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all possible intervals from a given chromosome considering a chromosome sizes dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bins : int, optional</span>
<span class="sd">        Size of the desired bin, by default 2000., by default 2000</span>
<span class="sd">    chrom_sizes_dict : str</span>
<span class="sd">        Path to a dictionary containing chromosome sizes as {chromosome : size} saved in .npy format. By default chromosome_sizes.npy</span>
<span class="sd">    chromosome : str, optional</span>
<span class="sd">        Chromosome to get intervals from, by default &quot;&quot;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[(int, int)]</span>
<span class="sd">        List containing the intervals as [(start, end), ...]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chromosome_size_dictionary</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_dictionary</span><span class="p">(</span><span class="n">chrom_sizes_dict</span><span class="p">)</span>

    <span class="n">nb_bins</span> <span class="o">=</span> <span class="n">chromosome_size_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">//</span> <span class="n">bins</span> <span class="o">+</span> <span class="mi">1</span> 

    <span class="n">intervals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="n">bins</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bins</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nb_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="c1"># -1 to exclude last bin to avoid anchor position error while constructing maps with cooler</span>

    <span class="k">return</span> <span class="n">intervals</span></div>

    
<div class="viewcode-block" id="draw_intervals">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.draw_intervals">[docs]</a>
<span class="k">def</span> <span class="nf">draw_intervals</span><span class="p">(</span><span class="n">nb_intervals</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bins</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">chrom_sizes_dict</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;chromosome_sizes.npy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draw intervals from a given chromosome sizes dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nb_intervals : int, optional</span>
<span class="sd">        Number of intervals to draw, by default 1</span>
<span class="sd">    bins : int, optional</span>
<span class="sd">        Size of the desired bin, by default 2000., by default 2000</span>
<span class="sd">    chrom_sizes_dict : str</span>
<span class="sd">        Path to a dictionary containing chromosome sizes as {chromosome : size} saved in .npy format. By default chromosome_sizes.npy</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict[str, list[tuple[int, int]]]</span>
<span class="sd">        Dictionary containing the intervals as {chromosome : [(start, end), ...]}.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get porportions by chromosome</span>
    <span class="n">intervals_proportion</span> <span class="o">=</span> <span class="n">get_intervals_proportions</span><span class="p">(</span><span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chrom_sizes_dict</span><span class="p">,</span> <span class="n">nb_intervals</span> <span class="o">=</span> <span class="n">nb_intervals</span><span class="p">)</span>

    <span class="c1"># Define placeholder for intervals</span>
    <span class="n">selected_intervals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">intervals_proportion</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

        <span class="n">candidate_intervals</span> <span class="o">=</span> <span class="n">get_chromosomes_intervals</span><span class="p">(</span><span class="n">chrom_sizes_dict</span> <span class="o">=</span> <span class="n">chrom_sizes_dict</span><span class="p">,</span> <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">)</span>
        <span class="n">picked_interval_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidate_intervals</span><span class="p">)),</span> <span class="n">size</span> <span class="o">=</span> <span class="n">intervals_proportion</span><span class="p">[</span><span class="n">chrom</span><span class="p">],</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">selected_intervals</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">candidate_intervals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">picked_interval_indexes</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">selected_intervals</span></div>


<div class="viewcode-block" id="get_boundaries">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_boundaries">[docs]</a>
<span class="k">def</span> <span class="nf">get_boundaries</span><span class="p">(</span><span class="n">position</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bins</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">chrom_sizes_dict</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;chromosome_sizes.npy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return boundaries surrounding position considering regular binning of bins.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    position : int, optional</span>
<span class="sd">        Position to get surrounding boundaries from, by default None</span>
<span class="sd">    bins : int, optional</span>
<span class="sd">        Size of the desired bin, by default 2000., by default 2000</span>
<span class="sd">    chromosome : str or list[str], optional</span>
<span class="sd">        Chromosomes associated to positions to get surrounding boundaries from, by default None</span>
<span class="sd">    chrom_sizes_dict : str</span>
<span class="sd">        Path to a dictionary containing chromosome sizes as {chromosome : size} saved in .npy format. By default chromosome_sizes.npy</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[int, int]</span>
<span class="sd">        Tuple containing the boundaries of the position : (lower_bound, upper_bound).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">chrom_sizes_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">chrom_sizes_dict</span><span class="p">)</span>
    <span class="n">chrom_sizes</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">load_dictionary</span><span class="p">(</span><span class="n">chrom_sizes_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  

        <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">area_to_search</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">bins</span><span class="p">,</span> <span class="n">chrom_sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chromosome</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">bins</span><span class="p">,</span> <span class="n">bins</span><span class="p">),</span> <span class="c1"># np.arange(0, cs_disctionary.item().get(chromosome) - bin_size, bin_size)</span>
        <span class="n">chrom_sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chromosome</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">position</span> <span class="o">%</span> <span class="n">bins</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">before_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">area_to_search</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">after_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">area_to_search</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">before_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">area_to_search</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">after_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">area_to_search</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>

    <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">area_to_search</span><span class="p">[</span><span class="n">before_index</span><span class="p">],</span> <span class="n">area_to_search</span><span class="p">[</span><span class="n">after_index</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_emptiness">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.check_emptiness">[docs]</a>
<span class="k">def</span> <span class="nf">check_emptiness</span><span class="p">(</span><span class="n">intervals</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]],</span> <span class="n">matrix</span> <span class="p">:</span> <span class="n">cooler</span><span class="o">.</span><span class="n">Cooler</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if intervals are empty in a given matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intervals : dict[str, list[(int, int)]</span>
<span class="sd">        Lists of intervals (sets) where the value is not in between as element 0 and where the value is  in between as element 1.</span>
<span class="sd">        One list per chromosome in a dictionary.</span>
<span class="sd">    matrix : cooler.Cooler, optional</span>
<span class="sd">        Cooler Hi-C matrix to be checked for emptiness, by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Returns True if one of the intervals are empty in the matrix, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">[</span><span class="n">chrom</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">matrix</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">balance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">fetch</span><span class="p">((</span><span class="n">chrom</span><span class="p">,</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="get_bin_indexes">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_bin_indexes">[docs]</a>
<span class="k">def</span> <span class="nf">get_bin_indexes</span><span class="p">(</span><span class="n">matrix</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dictionary</span> <span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the bins indexes (in the cooler matrix) corresponding to the genomic coordinates in the dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    matrix : str, optional</span>
<span class="sd">        Path to a cooler matrix file, by default None</span>
<span class="sd">    dictionary : dict, optional</span>
<span class="sd">        Dictionary of genomic coordinates where reads are going to be selected for duplication, by default None</span>
<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="n">bin_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">chrm</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">chrm</span><span class="p">]:</span>
            <span class="n">bin_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">bins</span><span class="p">()</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">chrm</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">bin_list</span></div>


<div class="viewcode-block" id="arange_multi">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.arange_multi">[docs]</a>
<span class="k">def</span> <span class="nf">arange_multi</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">stops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lengths</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create concatenated ranges of integers for multiple start/length.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    starts : numpy.ndarray</span>
<span class="sd">        Starts for each range</span>
<span class="sd">    stops : numpy.ndarray</span>
<span class="sd">        Stops for each range</span>
<span class="sd">    lengths : numpy.ndarray</span>
<span class="sd">        Lengths for each range. Either stops or lengths must be provided.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    concat_ranges : numpy.ndarray</span>
<span class="sd">        Concatenated ranges.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See the following illustrative example:</span>
<span class="sd">    starts = np.array([1, 3, 4, 6])</span>
<span class="sd">    stops = np.array([1, 5, 7, 6])</span>
<span class="sd">    print arange_multi(starts, lengths)</span>
<span class="sd">    &gt;&gt;&gt; [3 4 4 5 6]</span>
<span class="sd">    From: https://codereview.stackexchange.com/questions/83018/vectorized-numpy-version-of-arange-with-multiple-start-stop</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">stops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either stops or lengths must be provided!&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">stops</span> <span class="o">-</span> <span class="n">starts</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">starts</span><span class="p">):</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stops</span><span class="p">),</span> <span class="n">starts</span><span class="p">)</span>

    <span class="c1"># Repeat start position index length times and concatenate</span>
    <span class="n">cat_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">lengths</span><span class="p">)</span>

    <span class="c1"># Create group counter that resets for each start/length</span>
    <span class="n">cat_counter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lengths</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
        <span class="n">lengths</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span> <span class="o">-</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">lengths</span>
    <span class="p">)</span>

    <span class="c1"># Add group counter to group specific starts</span>
    <span class="n">cat_range</span> <span class="o">=</span> <span class="n">cat_start</span> <span class="o">+</span> <span class="n">cat_counter</span>

    <span class="k">return</span> <span class="n">cat_range</span></div>


<span class="k">def</span> <span class="nf">_overlap_intervals_legacy</span><span class="p">(</span><span class="n">starts1</span><span class="p">,</span> <span class="n">ends1</span><span class="p">,</span> <span class="n">starts2</span><span class="p">,</span> <span class="n">ends2</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take two sets of intervals and return the indices of pairs of overlapping intervals.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    starts1, ends1, starts2, ends2 : numpy.ndarray</span>
<span class="sd">        Interval coordinates. Warning: if provided as pandas.Series, indices</span>
<span class="sd">        will be ignored.</span>
<span class="sd">    closed : bool</span>
<span class="sd">        If True, then treat intervals as closed and report single-point overlaps.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    overlap_ids : numpy.ndarray</span>
<span class="sd">        An Nx2 array containing the indices of pairs of overlapping intervals.</span>
<span class="sd">        The 1st column contains ids from the 1st set, the 2nd column has ids</span>
<span class="sd">        from the 2nd set.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># for vec in [starts1, ends1, starts2, ends2]:</span>
    <span class="c1">#     if issubclass(type(vec), pd.core.series.Series):</span>
    <span class="c1">#         warnings.warn(</span>
    <span class="c1">#             &quot;One of the inputs is provided as pandas.Series and its index &quot;</span>
    <span class="c1">#             &quot;will be ignored.&quot;,</span>
    <span class="c1">#             SyntaxWarning,</span>
    <span class="c1">#         )</span>

    <span class="n">starts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">starts1</span><span class="p">)</span>
    <span class="n">ends1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ends1</span><span class="p">)</span>
    <span class="n">starts2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">starts2</span><span class="p">)</span>
    <span class="n">ends2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ends2</span><span class="p">)</span>

    <span class="c1"># Concatenate intervals lists</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">starts1</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">starts2</span><span class="p">)</span>
    <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">starts1</span><span class="p">,</span> <span class="n">starts2</span><span class="p">])</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ends1</span><span class="p">,</span> <span class="n">ends2</span><span class="p">])</span>

    <span class="c1"># Encode interval ids as 1-based,</span>
    <span class="c1"># negative ids for the 1st set, positive ids for 2nd set</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

    <span class="c1"># Sort all intervals together</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">([</span><span class="n">ends</span><span class="p">,</span> <span class="n">starts</span><span class="p">])</span>
    <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">,</span> <span class="n">ids</span> <span class="o">=</span> <span class="n">starts</span><span class="p">[</span><span class="n">order</span><span class="p">],</span> <span class="n">ends</span><span class="p">[</span><span class="n">order</span><span class="p">],</span> <span class="n">ids</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

    <span class="c1"># Find interval overlaps</span>
    <span class="n">match_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">)</span>
    <span class="n">match_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span> <span class="k">if</span> <span class="n">closed</span> <span class="k">else</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Ignore self-overlaps</span>
    <span class="n">match_mask</span> <span class="o">=</span> <span class="n">match_ends</span> <span class="o">&gt;</span> <span class="n">match_starts</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">match_starts</span><span class="p">,</span> <span class="n">match_ends</span> <span class="o">=</span> <span class="n">match_starts</span><span class="p">[</span><span class="n">match_mask</span><span class="p">],</span> <span class="n">match_ends</span><span class="p">[</span><span class="n">match_mask</span><span class="p">]</span>

    <span class="c1"># Restore</span>
    <span class="n">overlap_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="n">match_starts</span><span class="p">],</span> <span class="n">match_ends</span> <span class="o">-</span> <span class="n">match_starts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">ids</span><span class="p">[</span><span class="n">arange_multi</span><span class="p">(</span><span class="n">match_starts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">match_ends</span><span class="p">)],</span>
        <span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Drop same-set overlaps</span>
    <span class="n">overlap_ids</span> <span class="o">=</span> <span class="n">overlap_ids</span><span class="p">[</span><span class="n">overlap_ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">overlap_ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Flip overlaps, such that the 1st column contains ids from the 1st set,</span>
    <span class="c1"># the 2nd column contains ids from the 2nd set.</span>
    <span class="n">overlap_ids</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Restore original indexes,</span>
    <span class="n">overlap_ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlap_ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">overlap_ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlap_ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Sort overlaps according to the 1st</span>
    <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
        <span class="n">overlap_ids</span> <span class="o">=</span> <span class="n">overlap_ids</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">([</span><span class="n">overlap_ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">overlap_ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]])]</span>

    <span class="k">return</span> <span class="n">overlap_ids</span>

<div class="viewcode-block" id="overlap_intervals">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.overlap_intervals">[docs]</a>
<span class="k">def</span> <span class="nf">overlap_intervals</span><span class="p">(</span><span class="n">starts1</span><span class="p">,</span> <span class="n">ends1</span><span class="p">,</span> <span class="n">starts2</span><span class="p">,</span> <span class="n">ends2</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take two sets of intervals and return the indices of pairs of overlapping intervals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    starts1, ends1, starts2, ends2 : numpy.ndarray</span>
<span class="sd">        Interval coordinates. Warning: if provided as pandas.Series, indices</span>
<span class="sd">        will be ignored.</span>

<span class="sd">    closed : bool</span>
<span class="sd">        If True, then treat intervals as closed and report single-point overlaps.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    overlap_ids : numpy.ndarray</span>
<span class="sd">        An Nx2 array containing the indices of pairs of overlapping intervals.</span>
<span class="sd">        The 1st column contains ids from the 1st set, the 2nd column has ids</span>
<span class="sd">        from the 2nd set.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># for vec in [starts1, ends1, starts2, ends2]:</span>
    <span class="c1">#     if issubclass(type(vec), pd.core.series.Series):</span>
    <span class="c1">#         warnings.warn(</span>
    <span class="c1">#             &quot;One of the inputs is provided as pandas.Series and its index &quot;</span>
    <span class="c1">#             &quot;will be ignored.&quot;,</span>
    <span class="c1">#             SyntaxWarning,</span>
    <span class="c1">#         )</span>

    <span class="n">starts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">starts1</span><span class="p">)</span>
    <span class="n">ends1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ends1</span><span class="p">)</span>
    <span class="n">starts2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">starts2</span><span class="p">)</span>
    <span class="n">ends2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ends2</span><span class="p">)</span>

    <span class="c1"># Concatenate intervals lists</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">starts1</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">starts2</span><span class="p">)</span>
    <span class="n">ids1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
    <span class="n">ids2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>

    <span class="c1"># Sort all intervals together</span>
    <span class="n">order1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">([</span><span class="n">ends1</span><span class="p">,</span> <span class="n">starts1</span><span class="p">])</span>
    <span class="n">order2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">([</span><span class="n">ends2</span><span class="p">,</span> <span class="n">starts2</span><span class="p">])</span>
    <span class="n">starts1</span><span class="p">,</span> <span class="n">ends1</span><span class="p">,</span> <span class="n">ids1</span> <span class="o">=</span> <span class="n">starts1</span><span class="p">[</span><span class="n">order1</span><span class="p">],</span> <span class="n">ends1</span><span class="p">[</span><span class="n">order1</span><span class="p">],</span> <span class="n">ids1</span><span class="p">[</span><span class="n">order1</span><span class="p">]</span>
    <span class="n">starts2</span><span class="p">,</span> <span class="n">ends2</span><span class="p">,</span> <span class="n">ids2</span> <span class="o">=</span> <span class="n">starts2</span><span class="p">[</span><span class="n">order2</span><span class="p">],</span> <span class="n">ends2</span><span class="p">[</span><span class="n">order2</span><span class="p">],</span> <span class="n">ids2</span><span class="p">[</span><span class="n">order2</span><span class="p">]</span>

    <span class="c1"># Find interval overlaps</span>
    <span class="n">match_2in1_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">starts2</span><span class="p">,</span> <span class="n">starts1</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">match_2in1_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">starts2</span><span class="p">,</span> <span class="n">ends1</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span> <span class="k">if</span> <span class="n">closed</span> <span class="k">else</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="c1"># &quot;right&quot; is intentional here to avoid duplication</span>
    <span class="n">match_1in2_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">starts1</span><span class="p">,</span> <span class="n">starts2</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
    <span class="n">match_1in2_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">starts1</span><span class="p">,</span> <span class="n">ends2</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span> <span class="k">if</span> <span class="n">closed</span> <span class="k">else</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Ignore self-overlaps</span>
    <span class="n">match_2in1_mask</span> <span class="o">=</span> <span class="n">match_2in1_ends</span> <span class="o">&gt;</span> <span class="n">match_2in1_starts</span>
    <span class="n">match_1in2_mask</span> <span class="o">=</span> <span class="n">match_1in2_ends</span> <span class="o">&gt;</span> <span class="n">match_1in2_starts</span>
    <span class="n">match_2in1_starts</span><span class="p">,</span> <span class="n">match_2in1_ends</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">match_2in1_starts</span><span class="p">[</span><span class="n">match_2in1_mask</span><span class="p">],</span>
        <span class="n">match_2in1_ends</span><span class="p">[</span><span class="n">match_2in1_mask</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">match_1in2_starts</span><span class="p">,</span> <span class="n">match_1in2_ends</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">match_1in2_starts</span><span class="p">[</span><span class="n">match_1in2_mask</span><span class="p">],</span>
        <span class="n">match_1in2_ends</span><span class="p">[</span><span class="n">match_1in2_mask</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Generate IDs of pairs of overlapping intervals</span>
    <span class="n">overlap_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ids1</span><span class="p">[</span><span class="n">match_2in1_mask</span><span class="p">],</span> <span class="n">match_2in1_ends</span> <span class="o">-</span> <span class="n">match_2in1_starts</span><span class="p">)[</span>
                    <span class="p">:,</span> <span class="kc">None</span>
                <span class="p">],</span>
                <span class="n">ids2</span><span class="p">[</span><span class="n">arange_multi</span><span class="p">(</span><span class="n">match_2in1_starts</span><span class="p">,</span> <span class="n">match_2in1_ends</span><span class="p">)][:,</span> <span class="kc">None</span><span class="p">],</span>
            <span class="p">],</span>
            <span class="p">[</span>
                <span class="n">ids1</span><span class="p">[</span><span class="n">arange_multi</span><span class="p">(</span><span class="n">match_1in2_starts</span><span class="p">,</span> <span class="n">match_1in2_ends</span><span class="p">)][:,</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ids2</span><span class="p">[</span><span class="n">match_1in2_mask</span><span class="p">],</span> <span class="n">match_1in2_ends</span> <span class="o">-</span> <span class="n">match_1in2_starts</span><span class="p">)[</span>
                    <span class="p">:,</span> <span class="kc">None</span>
                <span class="p">],</span>
            <span class="p">],</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
        <span class="c1"># Sort overlaps according to the 1st</span>
        <span class="n">overlap_ids</span> <span class="o">=</span> <span class="n">overlap_ids</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">([</span><span class="n">overlap_ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">overlap_ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]])]</span>

    <span class="k">return</span> <span class="n">overlap_ids</span></div>


<div class="viewcode-block" id="overlap_intervals_outer">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.overlap_intervals_outer">[docs]</a>
<span class="k">def</span> <span class="nf">overlap_intervals_outer</span><span class="p">(</span><span class="n">starts1</span><span class="p">,</span> <span class="n">ends1</span><span class="p">,</span> <span class="n">starts2</span><span class="p">,</span> <span class="n">ends2</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take two sets of intervals and return the indices of pairs of overlapping intervals,</span>
<span class="sd">    as well as the indices of the intervals that do not overlap any other interval.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    starts1, ends1, starts2, ends2 : numpy.ndarray</span>
<span class="sd">        Interval coordinates. Warning: if provided as pandas.Series, indices</span>
<span class="sd">        will be ignored.</span>

<span class="sd">    closed : bool</span>
<span class="sd">        If True, then treat intervals as closed and report single-point overlaps.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    overlap_ids : numpy.ndarray</span>
<span class="sd">        An Nx2 array containing the indices of pairs of overlapping intervals.</span>
<span class="sd">        The 1st column contains ids from the 1st set, the 2nd column has ids</span>
<span class="sd">        from the 2nd set.</span>

<span class="sd">    no_overlap_ids1, no_overlap_ids2 : numpy.ndarray</span>
<span class="sd">        Two 1D arrays containing the indices of intervals in sets 1 and 2</span>
<span class="sd">        respectively that do not overlap with any interval in the other set.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ovids</span> <span class="o">=</span> <span class="n">overlap_intervals</span><span class="p">(</span><span class="n">starts1</span><span class="p">,</span> <span class="n">ends1</span><span class="p">,</span> <span class="n">starts2</span><span class="p">,</span> <span class="n">ends2</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">)</span>
    <span class="n">no_overlap_ids1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">ovids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">minlength</span><span class="o">=</span><span class="n">starts1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">no_overlap_ids2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">ovids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">minlength</span><span class="o">=</span><span class="n">starts2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ovids</span><span class="p">,</span> <span class="n">no_overlap_ids1</span><span class="p">,</span> <span class="n">no_overlap_ids2</span></div>


<div class="viewcode-block" id="intersect2D">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.intersect2D">[docs]</a>
<span class="k">def</span> <span class="nf">intersect2D</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find row intersection between 2D numpy arrays, a and b.</span>
<span class="sd">    Returns another numpy array with shared rows</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">)])</span></div>


<div class="viewcode-block" id="get_TP_table">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_TP_table">[docs]</a>
<span class="k">def</span> <span class="nf">get_TP_table</span><span class="p">(</span><span class="n">df_pattern</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">bin_size</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">jitter</span> <span class="p">:</span> <span class="nb">int</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take dataframe of pattern call (Chromosight) before and after reconstruction</span>
<span class="sd">    and return table of retieved patterns </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_pattern : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight before HiC map reconstruction.</span>
<span class="sd">    df_pattern_recall : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight after HiC map reconstruction.</span>
<span class="sd">    chromosome : [str]</span>
<span class="sd">        chromosome to select position within.</span>
<span class="sd">    bin_size : [int]</span>
<span class="sd">        bin size used to construct the HiC map.</span>
<span class="sd">    jitter : [int]</span>
<span class="sd">        jitter to apply to the pattern recall table to allow overlapping with the pattern table. By default 0.</span>
<span class="sd">    threshold : [float]</span>
<span class="sd">        threshold to apply to the pattern table to select patterns to consider. By default None.</span>

<span class="sd">    Return</span>
<span class="sd">    ----------</span>

<span class="sd">    dataframe : [pandas DataFrame]</span>
<span class="sd">        Table containing components before and after pattern recall (True positives)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_pattern</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">df_pattern</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">df_pattern_recall</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">df_pattern_recall</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Selection of chromosomes of interest</span>
        <span class="n">df_1</span> <span class="o">=</span> <span class="n">df_pattern</span><span class="p">[</span><span class="n">df_pattern</span><span class="p">[</span><span class="s2">&quot;chrom1&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chromosome</span><span class="p">]</span>
        <span class="n">df_2</span> <span class="o">=</span> <span class="n">df_pattern_recall</span><span class="p">[</span><span class="n">df_pattern_recall</span><span class="p">[</span><span class="s2">&quot;chrom1&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chromosome</span><span class="p">]</span>

    <span class="k">else</span> <span class="p">:</span>

        <span class="n">df_1</span> <span class="o">=</span> <span class="n">df_pattern</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;chrom1 == @chromosome and score &gt; @threshold&quot;</span><span class="p">)</span>
        <span class="n">df_2</span> <span class="o">=</span> <span class="n">df_pattern_recall</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;chrom1 == @chromosome and score &gt; @threshold&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">jitter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">jitter</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">)</span> 
        <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">jitter</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">)</span>

    <span class="c1"># Getting overlaps indexes for left side (start1; end1) for both before and afetr pattern recall</span>
    <span class="n">before_after_left</span> <span class="o">=</span> <span class="n">_overlap_intervals_legacy</span><span class="p">(</span><span class="n">starts1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">],</span> <span class="n">ends1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">],</span> <span class="n">starts2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">],</span> <span class="n">ends2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">],</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Getting overlaps indexes for left side (start2; end2) for both before and afetr pattern recall</span>
    <span class="n">before_after_right</span> <span class="o">=</span> <span class="n">_overlap_intervals_legacy</span><span class="p">(</span><span class="n">starts1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;start2&quot;</span><span class="p">],</span> <span class="n">ends1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;end2&quot;</span><span class="p">],</span> <span class="n">starts2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start2&quot;</span><span class="p">],</span> <span class="n">ends2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end2&quot;</span><span class="p">],</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Getting intersection of indeces (left/right) common to  before and after tables</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="n">intersect2D</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">before_after_left</span> <span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">before_after_right</span><span class="p">)</span>

    <span class="c1"># Pick lines through indexes to construct final table</span>
    <span class="n">lines_before</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">lines_after</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">lines_before</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_pattern</span><span class="p">[</span><span class="n">df_pattern</span><span class="p">[</span><span class="s1">&#39;chrom1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chromosome</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">selection</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">lines_after</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_pattern_recall</span><span class="p">[</span><span class="n">df_pattern_recall</span><span class="p">[</span><span class="s1">&#39;chrom1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chromosome</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">selection</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>

    <span class="n">final_before</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lines_before</span><span class="p">)</span>
    <span class="n">final_before</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;chrom1&quot;</span> <span class="p">:</span> <span class="s2">&quot;chrom1_before&quot;</span><span class="p">,</span> <span class="s2">&quot;start1&quot;</span> <span class="p">:</span> <span class="s2">&quot;start1_before&quot;</span><span class="p">,</span> <span class="s2">&quot;end1&quot;</span><span class="p">:</span> <span class="s2">&quot;end1_before&quot;</span> <span class="p">,</span> <span class="s2">&quot;chrom2&quot;</span><span class="p">:</span> <span class="s2">&quot;chrom2_before&quot;</span> <span class="p">,</span> <span class="s2">&quot;start2&quot;</span><span class="p">:</span> <span class="s2">&quot;start2_before&quot;</span> <span class="p">,</span> <span class="s2">&quot;end2&quot;</span> <span class="p">:</span> <span class="s2">&quot;end2_before&quot;</span> <span class="p">,</span> <span class="s2">&quot;score&quot;</span> <span class="p">:</span> <span class="s2">&quot;score_before&quot;</span><span class="p">},</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">final_before</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">final_after</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lines_after</span><span class="p">)</span>
    <span class="n">final_after</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;chrom1&quot;</span> <span class="p">:</span> <span class="s2">&quot;chrom1_after&quot;</span><span class="p">,</span> <span class="s2">&quot;start1&quot;</span> <span class="p">:</span> <span class="s2">&quot;start1_after&quot;</span><span class="p">,</span> <span class="s2">&quot;end1&quot;</span><span class="p">:</span> <span class="s2">&quot;end1_after&quot;</span> <span class="p">,</span> <span class="s2">&quot;chrom2&quot;</span><span class="p">:</span> <span class="s2">&quot;chrom2_after&quot;</span> <span class="p">,</span> <span class="s2">&quot;start2&quot;</span><span class="p">:</span> <span class="s2">&quot;start2_after&quot;</span> <span class="p">,</span> <span class="s2">&quot;end2&quot;</span> <span class="p">:</span> <span class="s2">&quot;end2_after&quot;</span> <span class="p">,</span> <span class="s2">&quot;score&quot;</span> <span class="p">:</span> <span class="s2">&quot;score_after&quot;</span><span class="p">},</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">final_after</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">true_positives_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">final_before</span><span class="p">,</span><span class="n">final_after</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">true_positives_table</span><span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_positives_table</span><span class="p">[</span><span class="s2">&quot;score_after&quot;</span><span class="p">]</span>
    <span class="n">true_positives_table</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_positives_table</span><span class="p">[</span><span class="s2">&quot;start1_after&quot;</span><span class="p">]</span>
    <span class="n">true_positives_table</span><span class="p">[</span><span class="s2">&quot;start2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_positives_table</span><span class="p">[</span><span class="s2">&quot;start2_after&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">true_positives_table</span></div>


<div class="viewcode-block" id="get_FN_table">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_FN_table">[docs]</a>
<span class="k">def</span> <span class="nf">get_FN_table</span><span class="p">(</span><span class="n">df_pattern</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">bin_size</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">jitter</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take dataframe of pattern call (Chromosight) before and after reconstruction</span>
<span class="sd">    and return table of retieved patterns </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_pattern : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight before HiC map reconstruction.</span>
<span class="sd">    df_pattern_recall : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight after HiC map reconstruction.</span>
<span class="sd">    chromosome : [str]</span>
<span class="sd">        chromosome to select position within.</span>
<span class="sd">    bin_size : [int]</span>
<span class="sd">        bin size used to construct the HiC map.</span>
<span class="sd">    jitter : [int]</span>
<span class="sd">        jitter to apply to the pattern recall table to allow overlapping with the pattern table. By default 0.</span>
<span class="sd">    threshold : [float]</span>
<span class="sd">        threshold to apply to the pattern table to select patterns to consider. By default None.</span>

<span class="sd">    Return</span>
<span class="sd">    ----------</span>

<span class="sd">    dataframe : [pandas DataFrame]</span>
<span class="sd">        Table containing components before and after pattern recall (True positives)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_pattern</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">df_pattern</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">df_pattern_recall</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">df_pattern_recall</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Selection of chromosomes of interest</span>
        <span class="n">df_1</span> <span class="o">=</span> <span class="n">df_pattern</span><span class="p">[</span><span class="n">df_pattern</span><span class="p">[</span><span class="s2">&quot;chrom1&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chromosome</span><span class="p">]</span>
        <span class="n">df_2</span> <span class="o">=</span> <span class="n">df_pattern_recall</span><span class="p">[</span><span class="n">df_pattern_recall</span><span class="p">[</span><span class="s2">&quot;chrom1&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chromosome</span><span class="p">]</span>

    <span class="k">else</span> <span class="p">:</span>

        <span class="n">df_1</span> <span class="o">=</span> <span class="n">df_pattern</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;chrom1 == @chromosome and score &gt; @threshold&quot;</span><span class="p">)</span>
        <span class="n">df_2</span> <span class="o">=</span> <span class="n">df_pattern_recall</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;chrom1 == @chromosome and score &gt; @threshold&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">jitter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">jitter</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">)</span> 
        <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">jitter</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">)</span>

    <span class="n">_left</span><span class="p">,</span> <span class="n">FN_left</span><span class="p">,</span> <span class="n">FP_left</span> <span class="o">=</span> <span class="n">overlap_intervals_outer</span><span class="p">(</span><span class="n">starts1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">],</span> <span class="n">ends1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">],</span> <span class="n">starts2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">],</span> <span class="n">ends2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">],</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">_right</span><span class="p">,</span> <span class="n">FN_right</span><span class="p">,</span> <span class="n">FP_right</span> <span class="o">=</span> <span class="n">overlap_intervals_outer</span><span class="p">(</span><span class="n">starts1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;start2&quot;</span><span class="p">],</span> <span class="n">ends1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;end2&quot;</span><span class="p">],</span> <span class="n">starts2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start2&quot;</span><span class="p">],</span> <span class="n">ends2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end2&quot;</span><span class="p">],</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">FN_intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">FN_left</span><span class="p">,</span> <span class="n">FN_right</span><span class="p">)</span>

    <span class="c1"># Pick lines through indexes to construct final table</span>
    <span class="n">lines_FN</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">FN_intersection</span><span class="p">:</span>
        <span class="n">lines_FN</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_1</span><span class="p">[</span><span class="n">df_1</span><span class="p">[</span><span class="s1">&#39;chrom1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chromosome</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="n">final_FN</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lines_FN</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_FN</span></div>


<div class="viewcode-block" id="get_FP_table">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_FP_table">[docs]</a>
<span class="k">def</span> <span class="nf">get_FP_table</span><span class="p">(</span><span class="n">df_pattern</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">bin_size</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">jitter</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take dataframe of pattern call (Chromosight) before and after reconstruction</span>
<span class="sd">    and return table of retieved patterns </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_pattern : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight before HiC map reconstruction.</span>
<span class="sd">    df_pattern_recall : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight after HiC map reconstruction.</span>
<span class="sd">    chromosome : [str]</span>
<span class="sd">        chromosome to select position within.</span>
<span class="sd">    bin_size : [int]</span>
<span class="sd">        bin size used to construct the HiC map.</span>
<span class="sd">    jitter : [int]</span>
<span class="sd">        jitter to apply to the pattern recall table to allow overlapping with the pattern table. By default 0.</span>
<span class="sd">    threshold : [float]</span>
<span class="sd">        threshold to apply to the pattern table to select patterns to consider. By default None.</span>

<span class="sd">    Return</span>
<span class="sd">    ----------</span>

<span class="sd">    dataframe : [pandas DataFrame]</span>
<span class="sd">        Table containing components before and after pattern recall (True positives)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_pattern</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">df_pattern</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">df_pattern_recall</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">df_pattern_recall</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Selection of chromosomes of interest</span>
        <span class="n">df_1</span> <span class="o">=</span> <span class="n">df_pattern</span><span class="p">[</span><span class="n">df_pattern</span><span class="p">[</span><span class="s2">&quot;chrom1&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chromosome</span><span class="p">]</span>
        <span class="n">df_2</span> <span class="o">=</span> <span class="n">df_pattern_recall</span><span class="p">[</span><span class="n">df_pattern_recall</span><span class="p">[</span><span class="s2">&quot;chrom1&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chromosome</span><span class="p">]</span>

    <span class="k">else</span> <span class="p">:</span>

        <span class="n">df_1</span> <span class="o">=</span> <span class="n">df_pattern</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;chrom1 == @chromosome and score &gt; @threshold&quot;</span><span class="p">)</span>
        <span class="n">df_2</span> <span class="o">=</span> <span class="n">df_pattern_recall</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;chrom1 == @chromosome and score &gt; @threshold&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">jitter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">jitter</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">)</span> 
        <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">jitter</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">)</span>

    <span class="n">_left</span><span class="p">,</span> <span class="n">FN_left</span><span class="p">,</span> <span class="n">FP_left</span> <span class="o">=</span> <span class="n">overlap_intervals_outer</span><span class="p">(</span><span class="n">starts1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">],</span> <span class="n">ends1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">],</span> <span class="n">starts2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start1&quot;</span><span class="p">],</span> <span class="n">ends2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end1&quot;</span><span class="p">],</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">_right</span><span class="p">,</span> <span class="n">FN_right</span><span class="p">,</span> <span class="n">FP_right</span> <span class="o">=</span> <span class="n">overlap_intervals_outer</span><span class="p">(</span><span class="n">starts1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;start2&quot;</span><span class="p">],</span> <span class="n">ends1</span> <span class="o">=</span> <span class="n">df_1</span><span class="p">[</span><span class="s2">&quot;end2&quot;</span><span class="p">],</span> <span class="n">starts2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;start2&quot;</span><span class="p">],</span> <span class="n">ends2</span> <span class="o">=</span> <span class="n">df_2</span><span class="p">[</span><span class="s2">&quot;end2&quot;</span><span class="p">],</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">FP_intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">FP_left</span><span class="p">,</span> <span class="n">FP_right</span><span class="p">)</span>

    <span class="c1"># Pick lines through indexes to construct final table</span>
    <span class="n">lines_FP</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines_FP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">else</span> <span class="p">:</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">FP_intersection</span><span class="p">:</span>
            <span class="n">lines_FP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_1</span><span class="p">[</span><span class="n">df_1</span><span class="p">[</span><span class="s1">&#39;chrom1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chromosome</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">final_FP</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lines_FP</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">final_FP</span></div>


<div class="viewcode-block" id="get_recall">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_recall">[docs]</a>
<span class="k">def</span> <span class="nf">get_recall</span><span class="p">(</span><span class="n">df_pattern</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">bin_size</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">jitter</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take dataframe of pattern call (Chromosight) before and after reconstruction</span>
<span class="sd">    and return recall score corresponding to the number of true positives over the number of true positives and false negatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_pattern : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight before HiC map reconstruction.</span>
<span class="sd">    df_pattern_recall : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight after HiC map reconstruction.</span>
<span class="sd">    chromosome : [str]</span>
<span class="sd">        chromosome to select position within.</span>
<span class="sd">    bin_size : [int]</span>
<span class="sd">        bin size used to construct the HiC map.</span>
<span class="sd">    jitter : [int]</span>
<span class="sd">        jitter to apply to the pattern recall table to allow overlapping with the pattern table. By default 0.</span>
<span class="sd">    threshold : [float]</span>
<span class="sd">        threshold to apply to the pattern table to select patterns to consider. By default None.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    recall : float</span>
<span class="sd">        number of true positives over the number of true positives and false negatives</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TP</span> <span class="o">=</span> <span class="n">get_TP_table</span><span class="p">(</span><span class="n">df_pattern</span> <span class="o">=</span> <span class="n">df_pattern</span> <span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="o">=</span> <span class="n">df_pattern_recall</span> <span class="p">,</span> <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">bin_size</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">jitter</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">FN</span> <span class="o">=</span> <span class="n">get_FN_table</span><span class="p">(</span><span class="n">df_pattern</span> <span class="o">=</span> <span class="n">df_pattern</span> <span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="o">=</span> <span class="n">df_pattern_recall</span> <span class="p">,</span> <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">bin_size</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">jitter</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span>  <span class="n">TP</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_precision">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_precision">[docs]</a>
<span class="k">def</span> <span class="nf">get_precision</span><span class="p">(</span><span class="n">df_pattern</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">bin_size</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">jitter</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take dataframe of pattern call (Chromosight) before and after reconstruction</span>
<span class="sd">    and return precision score corresponding to the number of true positives over the number of true positives and false positives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_pattern : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight before HiC map reconstruction.</span>
<span class="sd">    df_pattern_recall : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight after HiC map reconstruction.</span>
<span class="sd">    chromosome : [str]</span>
<span class="sd">        chromosome to select position within.</span>
<span class="sd">    bin_size : [int]</span>
<span class="sd">        bin size used to construct the HiC map.</span>
<span class="sd">    jitter : [int]</span>
<span class="sd">        jitter to apply to the pattern recall table to allow overlapping with the pattern table. By default 0.</span>
<span class="sd">    threshold : [float]</span>
<span class="sd">        threshold to apply to the pattern table to select patterns to consider. By default None.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    precision : float</span>
<span class="sd">        number of true positives over the number of true positives and false positives</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TP</span> <span class="o">=</span> <span class="n">get_TP_table</span><span class="p">(</span><span class="n">df_pattern</span> <span class="o">=</span> <span class="n">df_pattern</span> <span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="o">=</span> <span class="n">df_pattern_recall</span> <span class="p">,</span> <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">bin_size</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">jitter</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">get_FP_table</span><span class="p">(</span><span class="n">df_pattern</span> <span class="o">=</span> <span class="n">df_pattern</span> <span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="o">=</span> <span class="n">df_pattern_recall</span> <span class="p">,</span> <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">bin_size</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">jitter</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">FP</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span>  <span class="n">TP</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span><span class="p">)</span>
        
    <span class="n">FP</span> <span class="o">=</span> <span class="n">get_FP_table</span><span class="p">(</span><span class="n">df_pattern</span> <span class="o">=</span> <span class="n">df_pattern</span> <span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="o">=</span> <span class="n">df_pattern_recall</span> <span class="p">,</span> <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">bin_size</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">jitter</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span>  <span class="n">TP</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_f1_score">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_f1_score">[docs]</a>
<span class="k">def</span> <span class="nf">get_f1_score</span><span class="p">(</span><span class="n">df_pattern</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">bin_size</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">jitter</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take dataframe of pattern call (Chromosight) before and after reconstruction</span>
<span class="sd">    and return f1 score i.e. 2 * ((precision * recall) / (precision + recall)).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_pattern : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight before HiC map reconstruction.</span>
<span class="sd">    df_pattern_recall : [dataframe]</span>
<span class="sd">        Pandas DataFrame given by chromosight after HiC map reconstruction.</span>
<span class="sd">    chromosome : [str]</span>
<span class="sd">        chromosome to select position within.</span>
<span class="sd">    bin_size : [int]</span>
<span class="sd">        bin size used to construct the HiC map.</span>
<span class="sd">    jitter : [int]</span>
<span class="sd">        jitter to apply to the pattern recall table to allow overlapping with the pattern table. By default 0.</span>
<span class="sd">    threshold : [float]</span>
<span class="sd">        threshold to apply to the pattern table to select patterns to consider. By default None.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f1_score : float</span>
<span class="sd">        2 * ((precision * recall) / (precision + recall))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">recall</span> <span class="o">=</span> <span class="n">get_recall</span><span class="p">(</span><span class="n">df_pattern</span> <span class="o">=</span> <span class="n">df_pattern</span> <span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="o">=</span> <span class="n">df_pattern_recall</span> <span class="p">,</span> <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">bin_size</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">jitter</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">get_precision</span><span class="p">(</span><span class="n">df_pattern</span> <span class="o">=</span> <span class="n">df_pattern</span> <span class="p">,</span> <span class="n">df_pattern_recall</span> <span class="o">=</span> <span class="n">df_pattern_recall</span> <span class="p">,</span> <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">,</span> <span class="n">bin_size</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">jitter</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">precision</span> <span class="o">*</span> <span class="n">recall</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">+</span> <span class="n">recall</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_top_pattern">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.get_top_pattern">[docs]</a>
<span class="k">def</span> <span class="nf">get_top_pattern</span><span class="p">(</span><span class="n">file</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">top</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">threshold</span> <span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get top patterns from a dataframe</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame, optional</span>
<span class="sd">        Dataframe containing patterns given by Chromosight, by default None</span>
<span class="sd">    top : int, optional</span>
<span class="sd">        Percentage of top patterns to get, by default 10</span>
<span class="sd">    threshold : float, optional</span>
<span class="sd">        Pattern Pearson score to consider to select pattern, by default 0.0</span>
<span class="sd">    chromosome : str, optional</span>
<span class="sd">        Chromosome to consider, by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        Dataframe containing top percentage patterns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;score &gt; </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">chromosome</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;chrom1 == &#39;</span><span class="si">{</span><span class="n">chromosome</span><span class="si">}</span><span class="s2">&#39; and chrom2 == &#39;</span><span class="si">{</span><span class="n">chromosome</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
    <span class="n">top_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">top</span><span class="p">)</span> <span class="o">//</span> <span class="mi">100</span>
    <span class="n">df_top</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">top_factor</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_top</span></div>


<div class="viewcode-block" id="hicberg_benchmark_cmd_generator">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.hicberg_benchmark_cmd_generator">[docs]</a>
<span class="k">def</span> <span class="nf">hicberg_benchmark_cmd_generator</span><span class="p">(</span><span class="n">file</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">top</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">threshold</span> <span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">chromosome</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span>  <span class="n">genome</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bins</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">output</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get top patterns from a dataframe</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame, optional</span>
<span class="sd">        Dataframe containing patterns given by Chromosight, by default None</span>
<span class="sd">    top : int, optional</span>
<span class="sd">        Percentage of top patterns to get, by default 10</span>
<span class="sd">    threshold : float, optional</span>
<span class="sd">        Pattern Pearson score to consider to select pattern, by default 0.0</span>
<span class="sd">    chromosome : str, optional</span>
<span class="sd">        Chromosome to consider, by default None</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        Mode to consider for hicberg benchmark, by default &quot;full&quot;</span>
<span class="sd">    genome : str, optional</span>
<span class="sd">        Path to the genome to consider for hicberg benchmark, by default None</span>
<span class="sd">    bins : int, optional</span>
<span class="sd">        Number of bins to consider for hicberg benchmark, by default 0</span>
<span class="sd">    output : str, optional</span>
<span class="sd">        Path to the output folder to consider for hicberg benchmark, by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        HiC-BERG command line to run to evaluate reconstruction after pattern discarding</span>
<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="n">df</span> <span class="o">=</span> <span class="n">get_top_pattern</span><span class="p">(</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">chromosome</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;start1&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">stride</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start1</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;start1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

    <span class="n">cmd</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;hicberg benchmark -c </span><span class="si">{</span><span class="n">chromosome</span><span class="si">}</span><span class="s2"> -p </span><span class="si">{</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;start1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2"> -s </span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">stride</span><span class="p">))</span><span class="si">}</span><span class="s2"> -m </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> -g </span><span class="si">{</span><span class="n">genome</span><span class="si">}</span><span class="s2"> -b </span><span class="si">{</span><span class="n">bins</span><span class="si">}</span><span class="s2"> -o </span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">return</span> <span class="n">cmd</span></div>



<div class="viewcode-block" id="chromosight_cmd_generator">
<a class="viewcode-back" href="../../hicberg.html#hicberg.eval.chromosight_cmd_generator">[docs]</a>
<span class="k">def</span> <span class="nf">chromosight_cmd_generator</span><span class="p">(</span><span class="n">file</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pattern</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loops&quot;</span><span class="p">,</span> <span class="n">untrend</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">mode</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>  <span class="n">output_dir</span> <span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate chromosight command line to run pattern detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file : str, optional</span>
<span class="sd">        Path to Hi-C balanced contact matrix in .cool format , by default None</span>
<span class="sd">    pattern : str, optional</span>
<span class="sd">        Pattern to detect, by default &quot;loops&quot;</span>
<span class="sd">    untrend : bool, optional</span>
<span class="sd">        Set if map has to be detrended, by default True</span>
<span class="sd">    mode : bool, optional</span>
<span class="sd">        Set either the detection has to be performed before or after map reconstruction, by default False</span>
<span class="sd">    output_dir : str, optional</span>
<span class="sd">        Path to the folder where to save alignments, by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        Chromosight command line to run to run pattern detection</span>
<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">output_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output path </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing output path.&quot;</span><span class="p">)</span>
    
    <span class="n">matrix_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">matrix_path</span><span class="o">.</span><span class="n">suffix</span> <span class="o">!=</span> <span class="s2">&quot;.cool&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matrix path </span><span class="si">{</span><span class="n">matrix_path</span><span class="si">}</span><span class="s2"> is not a .cool file. Please provide a .cool file.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix_path</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matrix path </span><span class="si">{</span><span class="n">matrix_path</span><span class="si">}</span><span class="s2"> does not exist. Please provide existing matrix path.&quot;</span><span class="p">)</span>
    
    <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;original&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span> <span class="k">else</span> <span class="s2">&quot;rescued&quot;</span>

    <span class="k">if</span> <span class="n">untrend</span> <span class="p">:</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;chromosight detect -P </span><span class="si">{</span><span class="n">pattern</span><span class="si">}</span><span class="s2"> -T </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">output_path</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span>
    
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;chromosight detect -P </span><span class="si">{</span><span class="n">pattern</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">output_path</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">return</span> <span class="n">cmd</span></div>





</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Sébastien Gradit.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>